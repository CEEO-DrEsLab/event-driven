<!-- 
	Three column layout for a simple event-based programming interface

	Created by Caleb Lucas-Foley
	2016-07-11

	Most recently updated
	2016-07-14

	Next steps:
		Documentation
		Switch from +button to add blocks to dragging and dropping from the trigger and action banks
		Switch from my custom select-list-manager objects to a more robust MVC model
			Potentially link to EV3 brick (IoT)
		Play around with specific visual cues
		Consider cross-browser compatibility
		Demonstrate functionality and technology with a video
-->

<!DOCType html>
<html>
<head>
	<meta charset="utf-8">
	<title>Layout concept</title>
	<style>
	* {
		margin: 0px;
	}
	html, body {
		height: 100%;
		width: 100%;
	}
	/* Column column-header class */
	.column-header {
		height: 20px;
		text-align: center;
		background-color: gold;
	}
	/* Left column (trigger channel sidebar) */
	.left-column {
		position: absolute;
		width: 250px;
		left: 0;
	}
	/* Right column (action channel sidebar) */
	.right-column {
		position: absolute;
		width: 250px;
		right: 0;
	}
	/* Center column (code area) */
	.center-column {
		position: absolute;
		left: 250px;
		right: 250px;
	}
	/* Class for left and right sidebars */
	.sidebar {
		top: 20px;
		bottom: 0;
		background-color: lightgrey;
		overflow: auto;
		outline: 3px inset;
		outline-offset: -3px;
	}
	/* Class for code areas */
	.code-area {
		top: 20px;
		bottom: 0;
		background-color: dimgrey;
		overflow: auto;
		outline: 3px inset;
		outline-offset: -3px;
	}

	/* Channel block */
	.channel-block {
		height: 100px;
		width: 175px;
		text-align: center;
		margin: 10px auto; /* centers horizontally */
		border: 2px outset;
	}
	.channel-block, .action-block, .trigger-block:hover {
		cursor: grab;
	}
	/* Trigger channel */
	.trigger-channel {
		background-color: lightgreen;
	}
	/* Action channel */
	.action-channel {
		background-color: lightsalmon;
	}
	/* Buttons to add new blocks */
	.button-add {
		height: 50px;
		width: 50px;
		display: block;
		margin: 10px auto;
	}
	/* Code block parent */
	.group-container td {
		height: 100px;
		width: 200px;
	}
	/* Trigger-specific blocks */
	.trigger-block {
		background-color: forestgreen;
		border-radius: 0 0 0 25px;
		border: 2px outset;
		vertical-align: top;
		pointer-events: auto;
	}
	/* Action-specific blocks (also used for button positioning) */
	.action-block {
		background-color: crimson;
		border-radius: 0 0 25px 0;
		border: 2px outset;
		vertical-align: top;
		pointer-events: auto;
	}
	/* Trigger-action pair container */
	.group-container {
/*		background-color: cyan;*/
		margin: 10px auto; /* centers horizontally */
		min-height: 100px;
		pointer-events: none;
	}
	/* Delete Button */
	.delete-button {
		background-color: firebrick;
		float: right;
		top: 0;
		width: 20px;
		height: 20px;
		border: none;
		padding: 0;
		margin: 0;
		border: 2px inset;
		color: white;
	}
	/* Drag thumbnail */
	.drag-thumb {
		top: 0;
		right: 0;
		position: absolute;
		z-index: -1;
		border: 2px outset;
		width: 100px;
		height: 50px;
	}

	.cell-outline {
		border: 2px dashed black;
		vertical-align: center;
		text-align: center;
		color: black;
		font-size: 50px;
		pointer-events: none;
	}
	.invisible {
		visibility: hidden;
		border: 2px solid;
	}
	.left-cell {
		border-radius: 0 0 0 25px;
	}
	.right-cell {
		border-radius: 0 0 25px 0;
	}
	table, tr, span {
		pointer-events: none;
	}

	</style>
	<script async>
	//////////////////////////////////////////////////////////////////////
	//////////////////////////// "Constants" /////////////////////////////
	//////////////////////////////////////////////////////////////////////

	var PORTS = {
		input: ["1", "2", "3", "4"],
		output: ["A", "B", "C", "D"]
	}
	var BRICK = {
		input: ["Brick Button"],
		output: ["Brick Light", "Brick Sound"]
	}
	var SENSORS = ["Touch Sensor", "Ultrasonic Sensor", "Color Sensor"];
	var MOTORS = ["Large Motor", "Medium Motor"];


	//////////////////////////////////////////////////////////////////////
	///////////////////////////// Code Model /////////////////////////////
	//////////////////////////////////////////////////////////////////////

	// dust

	//////////////////////////////////////////////////////////////////////
	////////////////////// Helpful helper Functions //////////////////////
	//////////////////////////////////////////////////////////////////////

	// Adds an option with the value content to the select list parent
	function addNewOption(parent, content) {
		var newOption = document.createElement("option");
		newOption.text = content;
		parent.add(newOption);
	}

	/** Creates and returns an element of the specified channelType with the specified class */
	function createClassedElement(type, className) {
		var newElement = document.createElement(type);
		newElement.className = className;
		return newElement;
	}

	//////////////////////////////////////////////////////////////////////
	//////////////////////////// Data Managers ///////////////////////////
	//////////////////////////////////////////////////////////////////////

	/** Global manager of code block channels */
	portManager = {
		portConfig: {},
		listening: {},
		add: function(block, portID) {
			if (!this.listening[portID]) {
				this.listening[portID] = [];
			}
			this.listening[portID].push(block);
			block.innerHTML = this.portConfig[portID];
		},
		remove: function(block, portID) {
			this.listening[portID].splice(this.listening[portID].indexOf(block), 1);
		},
		update: function(portID, value) {
			this.portConfig[portID] = value;
			for (i in this.listening[portID]) {
				this.listening[portID][i].innerHTML = this.portConfig[portID];
			}
		}
	};

	// Manages a set of <select> objects s.t. selections are mutually exclusive
	ExclusiveListManager = function(pool) {
		return {
			lists: [],
			unclaimed: pool.slice(),
			claimed: [],
			update: function() {
				for (i in this.lists) {
					// Remove all non-selected options
					var temp = this.lists[i].value;
					this.lists[i].length = 0;
					addNewOption(this.lists[i], temp);
					// Re-add all available ports to each list
					for (k in this.unclaimed) {
						addNewOption(this.lists[i], this.unclaimed[k]);
					}
				}
			},
			claim: function(val) {
				this.unclaimed.splice(this.unclaimed.indexOf(val), 1);
				this.claimed.push(val);
			},
			declaim: function(val) {
				this.claimed.splice(this.claimed.indexOf(val), 1);
				this.unclaimed.push(val);
			},
			add: function(selectObject) {
				selectObject.manager = this;
				for (i in this.unclaimed) {
					addNewOption(selectObject, this.unclaimed[i]);
				}
				this.lists.push(selectObject);
				selectObject.oldValue = selectObject.value;
				this.claim(selectObject.value);
				this.update();
				selectObject.addEventListener("change", function () {
					this.manager.declaim(this.oldValue);
					this.manager.claim(this.value);
					this.manager.update();
				}, false);
			},
			remove: function(selectObject) {
				this.lists.splice(this.lists.indexOf(selectObject), 1);
				this.declaim(selectObject.value);
				this.update();
			}
		};
	};

	inputChannelManager = new ExclusiveListManager(PORTS.input);
	outputChannelManager = new ExclusiveListManager(PORTS.output);


	//////////////////////////////////////////////////////////////////////
	////////////////////////// New Block Setup ///////////////////////////
	//////////////////////////////////////////////////////////////////////

	function makeBlockOutline (side) {
		var dropZone = createClassedElement("td", "cell-outline " + side + "-cell");
		dropZone.id = "drop-zone";
		dropZone.innerHTML = "+";
		return dropZone;
	}

	function makeTriggerBlock (port) {
		var newBlock = createClassedElement("td", "trigger-block");
		var portLabel = document.createElement("span");
		portLabel.innerHTML = "Port: ";
		var portSelect = document.createElement("span");
		portSelect.innerHTML = port;
		var content = document.createElement("span");
		portManager.add(content, port);
		newBlock.appendChild(portLabel);
		newBlock.appendChild(portSelect);
		newBlock.appendChild(document.createElement("br"));
		newBlock.appendChild(content);

		newBlock.rowSpan = 2;

		var draggingOver = false;

		newBlock.addEventListener("drop", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel") {
				// Replace the dotted outline with the new block
				this.parentNode.parentNode.lastChild.replaceChild(
					makeActionBlock(data.port), this.parentNode.parentNode.lastChild.lastChild);
				draggingOver = false;
			} else if (data.type == "action-block") {
				// Replace the dotted outline with the MOVED block
				var toMove = removeActionBlock(document.getElementById("currently-dragging"));
				this.parentNode.parentNode.lastChild.replaceChild(
					toMove, this.parentNode.parentNode.lastChild.lastChild);
				draggingOver = false;
			} else if (data.type == "trigger-block") {
				this.style.outline = "";
				swapTriggers(this, document.getElementById("currently-dragging"));
				draggingOver = false;
			} else if (data.type == "trigger-channel") {
				this.style.outline = "";
				portManager.remove(content, port);
				port = data.port;
				portSelect.innerHTML = port;
				portManager.add(content, port);
				draggingOver = false;
			}
		}, false);
		newBlock.addEventListener("dragover", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
		}, false);
		newBlock.addEventListener("dragenter", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel" || data.type == "action-block") {
				if (!draggingOver) {
					draggingOver = true;
					// Show an outline of the spot where the action will go
					if (this.parentNode.nextSibling || this.nextSibling.firstChild) {
						// there is more than one row, or the block after this one has data in it
						var newRow = document.createElement("tr");
						newRow.appendChild(makeBlockOutline("right"));
						++this.rowSpan;
						this.parentNode.parentNode.appendChild(newRow);
					} else {
						this.parentNode.replaceChild(makeBlockOutline("right"), this.parentNode.lastChild);
					}
				}
			} else if (data.type == "trigger-block" || data.type == "trigger-channel") {
				if (!draggingOver) {
					draggingOver = true;
					this.style.outline = "2px dashed";
				}
			}
		}, false);
		newBlock.addEventListener("dragleave", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel" || data.type == "action-block") {
				draggingOver = false;
				// Stop showing the outline
				if (this.parentNode.nextSibling) {
					// More than one row right now
					this.parentNode.parentNode.removeChild(this.parentNode.parentNode.lastChild);
				} else {
					this.parentNode.replaceChild(
						createClassedElement("td", "invisible right-cell"), this.parentNode.lastChild);
				}
			} else if (data.type == "trigger-block" || data.type == "trigger-channel") {
				draggingOver = false;
				this.style.outline = "";
			}
		}, false);

		// make it draggable!
		newBlock.draggable = true;
		newBlock.addEventListener("dragstart", function (ev) {
			ev.stopPropagation();
			var data = {
				type: "trigger-block",
				port: port,
			};
			ev.dataTransfer.setData("text/plain", JSON.stringify(data));
			ev.dataTransfer.setDragImage(document.getElementById("trigger-drag-thumb"), 50, 25);
			this.style.opacity = 0.5;
			this.id = "currently-dragging";
		}, false);
		newBlock.addEventListener("dragend", function (ev) {
			ev.stopPropagation();
			this.id = "";
			this.style.opacity = 1;
		}, false);
		return newBlock;
	}

	function swapTriggers (trigger1, trigger2) {
		if (trigger1 === trigger2) {
			return;
		}
		// swap rowSpan values
		trigger1.rowSpan ^= trigger2.rowSpan;
		trigger2.rowSpan ^= trigger1.rowSpan;
		trigger1.rowSpan ^= trigger2.rowSpan;
		// swap DOM positions
		var temp = createClassedElement("td", "trigger-block");
		trigger1.parentNode.replaceChild(temp, trigger1);
		trigger2.parentNode.replaceChild(trigger1, trigger2);
		temp.parentNode.replaceChild(trigger2, temp);
	}

	function makeActionBlock (port) {
		var newBlock = createClassedElement("td", "action-block");
		var portLabel = document.createElement("span");
		portLabel.innerHTML = "Port: ";
		var portSelect = document.createElement("span");
		portSelect.innerHTML = port;
		var content = document.createElement("span");
		portManager.add(content, port);

		// var deleteButton = createClassedElement("button", "delete-button");
		// deleteButton.innerHTML = "X";
		// deleteButton.addEventListener("click", function () {
		// 	portManager.remove(portSelect, port);
		// 	var rowBelow = newBlock.parentNode.nextSibling;
		// 	newBlock.parentNode.replaceChild(rowBelow.firstChild, newBlock);
		// 	rowBelow.parentNode.removeChild(rowBelow);
		// });
		//newBlock.appendChild(deleteButton);

		// make the block droppable!
		draggingOver = false;

		newBlock.addEventListener("dragenter", function (ev) {
			console.log(ev);
			console.log(draggingOver);
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel" || data.type == "action-block") {
				if (!draggingOver) {
					draggingOver = true;
					// show the dotted outline below this block
					var newRow = document.createElement("tr");
					newRow.appendChild(makeBlockOutline("right"));
					++this.parentNode.parentNode.firstChild.firstChild.rowSpan;
					if (this.parentNode.nextSibling) {
						// this is not in the last row
						this.parentNode.parentNode.insertBefore(newRow, this.parentNode.nextSibling);
					} else {
						// this is in the last row
						this.parentNode.parentNode.appendChild(newRow);
					}
				}
			}
		}, false);
		newBlock.addEventListener("dragover", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
		}, false);
		newBlock.addEventListener("drop", function (ev) {
			console.log(ev);
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel") {
				// Replace the dotted outline with the new block
				this.parentNode.nextSibling.replaceChild(
					makeActionBlock(data.port), this.parentNode.nextSibling.firstChild);
				draggingOver = false;
			} else if (data.type == "action-block") {
				if (this !== document.getElementById("currently-dragging")) {
					// Replace the dotted outline with the MOVED block
					var toMove = removeActionBlock(document.getElementById("currently-dragging"));
					this.parentNode.nextSibling.replaceChild(toMove, this.parentNode.nextSibling.lastChild);
				} else {
					// remove the outline
					this.parentNode.parentNode.removeChild(this.parentNode.nextSibling);
				}
				draggingOver = false;
			}
		}, false);
		newBlock.addEventListener("dragleave", function (ev) {
			console.log(ev);
			ev.preventDefault();
			ev.stopPropagation();
			data = JSON.parse(ev.dataTransfer.getData("text/plain"));
			if (data.type == "action-channel" || data.type == "action-block") {
				draggingOver = false;
				this.parentNode.parentNode.removeChild(this.parentNode.nextSibling);
			}
		}, false);

		// make the block draggable
		newBlock.draggable = true;
		newBlock.addEventListener("dragstart", function (ev) {
			ev.stopPropagation();
			var data = {
				type: "action-block",
				port: port,
			};
			ev.dataTransfer.setData("text/plain", JSON.stringify(data));
			ev.dataTransfer.setDragImage(document.getElementById("action-drag-thumb"), 50, 25);
			this.id = "currently-dragging";
			this.style.opacity = 0.5;
		}, false);
		newBlock.addEventListener("dragend", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
			this.id = "";
			this.style.opacity = 1;
		}, false);

		newBlock.appendChild(portLabel);
		newBlock.appendChild(portSelect);
		newBlock.appendChild(document.createElement("br"));
		newBlock.appendChild(content);
		return newBlock;
	}

	function removeActionBlock (action) {
		if (action.parentNode.nextSibling) {
			// action is not in last row
			// replace action with next row's action, remove the now empty next row
			var rowBelow = action.parentNode.nextSibling;
		 	action.parentNode.replaceChild(rowBelow.firstChild, action);
		 	rowBelow.parentNode.removeChild(rowBelow);
		} else if (action.parentNode.previousSibling) {
			// action is in last row, and is not the only action
			// remove the row action is in
			action.parentNode.parentNode.removeChild(action.parentNode);
		} else {
			// only one action
			action.parentNode.replaceChild(createClassedElement("td", "invisible right-cell"), action);
		}
		return action;
	}

	// Make a new channel block (to be added to a sidebar) with an exclusive port selector
	function makeChannelBlock (channelType) {
		var newChannelBlock = createClassedElement("div", "channel-block " + channelType + "-channel");
		var portSelect = document.createElement("select");
		(channelType == "trigger" ? inputChannelManager : outputChannelManager).add(portSelect);
		portSelect.addEventListener("change", function () {
			portManager.update(this.oldValue, undefined);
			portManager.update(this.value, peripheralSelect.value);
			this.oldValue = this.value;
		});

		var peripheralSelect = document.createElement("select");
		for (i in (channelType == "trigger" ? SENSORS : MOTORS)) {
			addNewOption(peripheralSelect, (channelType == "trigger" ? SENSORS : MOTORS)[i]);
		}
		portManager.update(portSelect.value, peripheralSelect.value);
		peripheralSelect.addEventListener("change", function () {
			portManager.update(portSelect.value, this.value);
		});

		var deleteButton = createClassedElement("button", "delete-button");
		deleteButton.innerHTML = "X";
		deleteButton.addEventListener("click", function () {
			(channelType == "trigger" ? inputChannelManager : outputChannelManager).remove(portSelect);
			portManager.update(portSelect.value, undefined);
			newChannelBlock.parentNode.removeChild(newChannelBlock);
		});

		newChannelBlock.appendChild(deleteButton);
		newChannelBlock.appendChild(portSelect);
		newChannelBlock.appendChild(peripheralSelect);

		// Make the new channel draggable!
		newChannelBlock.draggable = true;
		newChannelBlock.addEventListener("dragstart", function (ev) {
			ev.stopPropagation();
			var data = {
				type: channelType + "-channel",
				port: portSelect.value,
			};
			ev.dataTransfer.setData("text/plain", JSON.stringify(data));
			ev.dataTransfer.setDragImage(document.getElementById(channelType + "-drag-thumb"), 50, 25);
			newChannelBlock.id = "currently-dragging";
		}, false);
		newChannelBlock.addEventListener("dragend", function (ev) {
			ev.preventDefault();
			ev.stopPropagation();
			newChannelBlock.id = "";
		}, false);

		return newChannelBlock;
	}


	//////////////////////////////////////////////////////////////////////
	/////////////////////// Adding New Code Blocks ///////////////////////
	//////////////////////////////////////////////////////////////////////

	// Adds a new channel block (of the specified channelType) above the specified element
	function addChannelBlockAbove(button, channelType) {
		if (channelType != "trigger" && channelType != "action") {
			alert("Error creating channel (invalid channel channelType)");
			return;
		}
		var newChannelBlock = makeChannelBlock(channelType);
		button.parentNode.insertBefore(newChannelBlock, button);
	}

	// Adds a single trigger, to which multiple actions can be added, above the specified element
	function addTrigger(parent, triggerPort) {
		var group = createClassedElement("table", "group-container");
		var topRow = document.createElement("tr");
		topRow.appendChild(makeTriggerBlock(triggerPort));
		topRow.appendChild(createClassedElement("td", "invisible right-cell"));
		group.appendChild(topRow);
		parent.appendChild(group);
	}

	function addTriggerOutline(parent) {
		var group = createClassedElement("table", "group-container");
		group.style.pointerEvents = "none";
		group.id = "group-drop-zone";
		var row = document.createElement("tr");
		var triggerDropZone = makeBlockOutline("left");
		var emptyCell = createClassedElement("td", "invisible right-cell");
		row.appendChild(triggerDropZone);
		row.appendChild(emptyCell);
		group.appendChild(row);
		parent.appendChild(group);
	}

	function removeTriggerOutline() {
		var toRemove = document.getElementById("group-drop-zone");
		toRemove.parentNode.removeChild(toRemove);
	}

	</script>
</head>

<body>
	<div class="drag-thumb trigger-block" id="trigger-drag-thumb"></div>
	<div class="drag-thumb action-block" id="action-drag-thumb"></div>
	<div class="left-column column-header">Trigger Channels:</div>
	<div class="right-column column-header">Action Channels:</div>
	<div class="center-column column-header">Code:</div>
	<div class="left-column sidebar" id="trigger-bank">
		<button class="button-add" onclick="addChannelBlockAbove(this, 'trigger')">+</button>
	</div>
	<div class="right-column sidebar" id="action-bank">
		<button class="button-add" onclick="addChannelBlockAbove(this, 'action')">+</button>
	</div>
	<div class="center-column code-area" id="code-area"></div>

	<script>
	// TODO move
	var draggingOver = false;

	document.getElementById("code-area").addEventListener("drop", function (ev) {
		ev.preventDefault();
		var data = JSON.parse(ev.dataTransfer.getData("text/plain"));
		if (data.type == "trigger-channel") {
			removeTriggerOutline();
			var data = JSON.parse(ev.dataTransfer.getData("text/plain")).port;
			addTrigger(this, data);
			draggingOver = false;
		}
	});
	document.getElementById("code-area").addEventListener("dragover", function (ev) {
		ev.preventDefault();
	});
	document.getElementById("code-area").addEventListener("dragenter", function (ev) {
		ev.preventDefault();
		var data = JSON.parse(ev.dataTransfer.getData("text/plain"));
		if (data.type == "trigger-channel") {
			if (!draggingOver) {
				draggingOver = true;
				addTriggerOutline(this);
			}
		}
	});
	document.getElementById("code-area").addEventListener("dragleave", function (ev) {
		ev.preventDefault();
		var data = JSON.parse(ev.dataTransfer.getData("text/plain"));
		if (data.type == "trigger-channel") {
			draggingOver = false;
			removeTriggerOutline();
		}
	});

	</script>
</body>

</html>